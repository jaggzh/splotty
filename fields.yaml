# In our state.yaml we store something like:
# last_state:
#   fieldspec_path: "..."
#   groups: # Stores current group states selected by the user
#           # when loaded, group states are merely their states for
#           # handling the effect of toggling.
#   fields: # stores individual field states. These will be each
#           # actual field's enabled/disabled plot state
#           # hidden: disables the field entirely, including its display and its plot

# See below for an actual in-use file

# Magnetometer sensor MCU project splotty fields spec file
# for Splotty, a Serial text-mode plotter.
#
# Field-groups for plot state and quick-toggles configuration
# Hitting key toggles entire group off (false) / on (true)
# Same with individual field toggles
groups:
  1:
    key: 1
    state: true
    order: 1
  2:
    key: 2
    state: true
    order: 1
  1-All:
    key: "!"
    state: false
    order: 1
  2-All:
    key: "@"
    state: false
    order: 1
  raw:
    key: "r"
    state: false
    order: 2
  btn:
    key: "b"
    state: false
    order: 2
  extra:
    key: "x"
    state: false
    order: 2
  1extra:
    key: "9"
    state: false
    order: 2
  2extra:
    key: "0"
    state: false
    order: 2

state:
  start: true
  # start: true => all fields start enabled
  # then group states applied in order (0 first)
  # groups' fields in plotter then begin in that state,
  #  and the key toggles their state, and all fields in
  #  that group are set to that new state

# ShortcutsAuto.pm: Used to map strings to chars, and the inverse map of
#    chars to strings. When run directly, has a default test list of
#    strings it runs itself on, OR accepts a list of strings as individual
#    cli args, and outputs the resultant char mapping.
# Used to choose shortcuts for our 'auto' groups and fields.
#
# Group and field keystrokes may be specified; the key is ADDED to the UI
# shortcuts. A warning is output upon conflict for each conflict and that
# keystroke is set to 'auto' mode.
# If any conflicts, follow the list of warnings by a
#   sleep($def_conflict_delay_s=1)
# For 'auto' keystrokes, an algorithm is implemented which
# analyzes all field names such that common prefix chars are
# ranked lower. Thus, chars d, 1, 2, ., and z, end up lower.
#   1. Go through all 'auto' fields:
#      fields_highmean = 75% percentile of all lengths???
#   2. Go through all 'auto' fields and calculate an
#        "early-commonality". Something like this unfinished undeveloped..
#   3. Module accepts a list of chars to exclude from candidates.
#      In our application, we combine our UI keys and our manually-specified
#      keys from the yaml for the exclude list.
#   4. Module accepts 
#   3. For each field:
#      chars = split //, $fieldname
#      for ci in (0 .. @chars):
#        c = $chars[ci]
#        c_commonality{c} += max(1,fields_highmean-ci))/fields_highmean
#        I don't know how to do this all
#   4. Fallback is to choose the first unassigned key.
#   5. If no assigned key, we go through any available [a-z], then [0-9],
#      then [A-Z].
defaults:
  fields:
    key_auto: true # fields with no "key:" get assigned auto instead of no assignment

fields:
  d1.Zraw:
    # d1.Zraw in groups 1 and 'raw'
    groups: [1, "1-All", "raw", "extra"]
    key: "auto"
    fg: 227
  d2.Zraw:
    groups: [2, "raw", "extra"]
    key: "auto"
    fg24: [255, 0, 255]
    bg24: [0, 0, 90]
    ch: "â”‡"
  d1.btn:
    groups: [1, "1-All", "btn"]
    key: "b"
  d2.btn:
    groups: [2, "btn"]
    key: "B"
  d1.chg_rate:
    groups: [1, "1-All", "extra", "1extra"]
    hidden: true
  d2.chg_rate:
    groups: [2, "1-All", "extra", "2extra"]
    hidden: true
  d1.humanPct:
    groups: [1, "1-All", "extra", "1extra"]
    key: "auto"
  d2.humanPct:
    groups: [2, "1-All", "extra"]
    key: "auto"
  d1.Zsmooth:
    groups: [1, "1-All"]
    key: "auto"
  d1.min:
    groups: [1, "1-All"]
    key: "auto"
  d1.max:
    groups: [1, "1-All"]
    key: "auto"
  d1.TrigH:
    groups: [1, "1-All"]
  d1.TrigL:
    groups: [1, "1-All"]
  d2.Zsmooth:
    groups: [2, "2-All"]
  d2.min:
    groups: [2, "2-All"]
  d2.max:
    groups: [2, "2-All"]
  d2.TrigH:
    groups: [2, "2-All"]
  d2.TrigL:
    groups: [2, "2-All"]

# Record of all fields is below, but they can be ignored.
# Any fields not added to a group remain in the start state
# d1.Zsmooth
# d1.min
# d1.max
# d1.TrigH
# d1.TrigL
# d1.btn
# d1.chg_rate
# d1.humanPct
# d2.Zraw
# d2.Zsmooth
# d2.min
# d2.max
# d2.TrigH
# d2.TrigL
# d2.btn
# d2.chg_rate
# d2.humanPct
