#!/usr/bin/env python3
from __future__ import annotations
import argparse
import asyncio
import uuid
from pathlib import Path
from textual.app import App, ComposeResult
from textual.containers import Horizontal, Vertical
from textual.widgets import Static, Tree, ListView, ListItem, Label, Footer
from textual.widgets._tree import TreeNode as TextualTreeNode
from textual import events
from textual.reactive import reactive
from textual.message import Message
from textual import log
from typing import Iterator, List, Optional, Tuple


from models import Preset, TreeNode as ModelNode, FieldDef
from storage import Storage

import re
import sys
import serial_asyncio
from serial.tools import list_ports

# ---------- Helpers ----------

def new_id(prefix: str = "n") -> str:
    return f"{prefix}-{uuid.uuid4().hex[:8]}"


def _get_cursor_node(tree: Tree) -> Optional[TreeNode]:
    """Return the current cursor node regardless of Textual minor version differences."""
    # Newer Textual versions often expose `cursor_node`; older expose `cursor` (node id) + get_node
    if hasattr(tree, "cursor_node"):
        return tree.cursor_node  # type: ignore[attr-defined]
    if hasattr(tree, "cursor"):
        node_id = tree.cursor  # type: ignore[attr-defined]
        if node_id is not None and hasattr(tree, "get_node"):
            try:
                return tree.get_node(node_id)
            except Exception:
                return None
    return None


def _iter_visible_nodes(root: TreeNode) -> Iterator[TreeNode]:
    """Preorder traversal of nodes as the user sees them (respects expansion)."""
    stack: List[TreeNode] = [root]
    while stack:
        node = stack.pop()
        yield node
        # Only descend if node is expanded or cannot expand (i.e., leaf)
        can_expand = getattr(node, "allow_expand", False)
        is_expanded = getattr(node, "expanded", False)
        if (not can_expand) or is_expanded:
            # Push children in reverse so we pop in natural order
            children = list(getattr(node, "children", []))
            for child in reversed(children):
                stack.append(child)


def _visible_nodes(tree: Tree) -> List[TreeNode]:
    """Materialize the visible node list for indexing."""
    return list(_iter_visible_nodes(tree.root))


def _tree_get_cursor_idx(tree: Tree) -> Tuple[int, int]:
    """
    Return (cursor_index, visible_count).
    If there is no cursor node, returns (0, visible_count) as a safe default.
    """
    nodes = _visible_nodes(tree)
    cursor = _get_cursor_node(tree)
    if cursor is None:
        return 0, len(nodes)
    try:
        return nodes.index(cursor), len(nodes)
    except ValueError:
        # Cursor node not visible (e.g., collapsed above); default to 0
        return 0, len(nodes)


def _expand_to_node(node: TreeNode) -> None:
    """Ensure all ancestors are expanded so `node` is visible."""
    parent = getattr(node, "parent", None)
    while parent is not None:
        # Only expand if it can expand
        if getattr(parent, "allow_expand", False):
            parent.expand()
        parent = getattr(parent, "parent", None)


def _tree_set_selected_by_idx(tree: Tree, idx: int, *, auto_expand: bool = True, clamp: bool = True) -> int:
    """
    Select the visible node at `idx`. Returns the index actually selected (after clamping).
    If `auto_expand` is True, expands ancestors so the node is visible.
    """
    nodes = _visible_nodes(tree)
    if not nodes:
        return 0
    if clamp:
        idx = max(0, min(idx, len(nodes) - 1))
    target = nodes[idx]
    if auto_expand:
        _expand_to_node(target)
    # This sets the cursor, scrolls into view, and emits the selected event
    tree.select_node(target)
    return idx

# ---------- Widgets ----------

class HeaderBar(Static):
    preset_name: reactive[str] = reactive("")
    device: reactive[str] = reactive("")
    baud: reactive[int] = reactive(115200)
    parity: reactive[str] = reactive("N")
    stopbits: reactive[int] = reactive(1)

    def render(self):
        return (
            f"{self.preset_name}    (Alt+s)Save   (q)quit   (d){self.device} "
            f"{self.baud} {self.parity}{self.stopbits}"
        )

class SerialPreview(Static):
    def set_preview(self, label_line: str | None, data_line: str | None) -> None:
        if label_line:
            self.update(f"{label_line}\n{data_line or ''}".rstrip())
        else:
            self.update(f"{data_line or ''}".rstrip())

class DynamicPane(Static):
    interactive: reactive[bool] = reactive(False)

class HelpBar(Static):
    pass

class FieldsList(ListView):
    class StartDrag(Message):
        def __init__(self, field_id: str, field_label: str) -> None:
            self.field_id = field_id
            self.field_label = field_label
            super().__init__()

    def on_mouse_down(self, event: events.MouseDown) -> None:
        # select the clicked item and initiate a drag intent
        if isinstance(event.sender, FieldsList):
            pass
            # # Textual selects by keyboard; we need to ensure selection follows click
            # if self.index is not None:
            #     item = self.children[self.index]
            # Find item by y coordinate approx: let Textual handle selection via click first
        # Let the click run default first so selection is updated
        self.post_message(self.StartDrag(self.selected_field_id, self.selected_field_label))

    @property
    def selected_field_id(self) -> str:
        item = self.get_selected_item()
        return getattr(item, "field_id", "") if item else ""

    @property
    def selected_field_label(self) -> str:
        item = self.get_selected_item()
        return getattr(item, "field_label", "") if item else ""

    def get_selected_item(self) -> ListItem | None:
        if self.index is None:
            return None
        try:
            return self.children[self.index]
        except Exception:
            return None

class FieldItem(ListItem):
    def __init__(self, field: FieldDef):
        super().__init__(Label(field.label))
        self.field_id = field.id
        self.field_label = field.label

class GroupTree(Tree):
    class DropField(Message):
        def __init__(self, field_id: str) -> None:
            self.field_id = field_id
            super().__init__()

    def on_mouse_up(self, event: events.MouseUp) -> None:
        app = self.app
        dragging = getattr(app, "dragging_field", None)
        if dragging:
            # Drop occurred on tree; insert relative to current selection
            self.post_message(self.DropField(dragging))
            app.dragging_field = None

# ---------- App ----------

class LabelManagerApp(App):
    CSS_PATH = "textual.css"
    BINDINGS = [
        ("tab", "cycle_focus", "Cycle focus"),
        ("q", "quit_confirm", "Quit"),
        ("d", "device_select", "Device"),
        ("alt+s", "save_preset", "Save"),
        ("m", "monitor", "Monitor"),
        # Tree keys
        ("h", "tree_collapse_one", None),
        ("H", "tree_collapse_all", None),
        ("l", "tree_expand_one", None),
        ("L", "tree_expand_all", None),
        ("j", "tree_down", None),
        ("k", "tree_up", None),
        ("J", "tree_move_down", None),
        ("K", "tree_move_up", None),
        ("-", "tree_delete", None),
        ("delete", "tree_delete", None),
        ("a", "tree_add_child", None),
        ("o", "tree_add_sibling", None),
        ("e", "tree_edit_or_insert", None),
    ]

    dragging_field: str | None = None  # global drag payload (field id)

    def __init__(self, preset_name: str, storage_dir: Path) -> None:
        super().__init__()
        self.storage = Storage(storage_dir)
        self.preset = self.storage.load(preset_name)
        self._mode: str | None = None
        self._devsel: dict | None = None
        self._edit_target: str | None = None
        self._edit_text: str = ""
        self._edit_cursor: int = 0

    # ---------- Compose ----------

    def compose(self) -> ComposeResult:
        self.header = HeaderBar(id="header")
        yield self.header

        with Horizontal(id="main-split"):
            with Vertical(id="tree-col"):
                self.group_tree = GroupTree("Root", id="tree")
                yield self.group_tree
            with Vertical(id="fields-col"):
                self.fields = FieldsList(id="fields")
                yield self.fields

        self.preview = SerialPreview(id="serial-preview")
        yield self.preview

        self.dynamic = DynamicPane(id="dynamic-pane")
        yield self.dynamic

        self.helpbar = HelpBar(id="help-line")
        yield self.helpbar

        yield Footer()

    # ---------- on_mount ----------

    def on_mount(self) -> None:
        # header info
        self.header.preset_name = self.preset.name
        self.header.device = self.preset.device
        self.header.baud = self.preset.baud
        self.header.parity = self.preset.parity
        self.header.stopbits = self.preset.stopbits

        # Tree populate
        self.populate_tree()

        self.populate_fields()

        # Preview
        if self.preset.last_preview:
            self.preview.set_preview(
                # self.preset.last_preview.get("label_line", ""),
                # self.preset.last_preview.get("data_line", ""),
                self.preset.last_preview.get("label_line"),
                self.preset.last_preview.get("data_line"),
            )

        self.update_help_for_tree()

    # ---------- Populate widgets ----------

    def populate_tree(self, offset: Optional[int] = None) -> None:
        # 1) Remember current cursor index among visible nodes
        cur_idx, visible_cnt = _tree_get_cursor_idx(self.group_tree)

        # 2) Rebuild from your model
        self.group_tree.root.label = self.preset.tree_nodes[self.preset.root_id].name
        self.group_tree.root.allow_expand = True
        self.group_tree.root.expand()
        self.group_tree.clear()

        def add_children(parent_txt_node: TreeNode, parent_id: str):
            parent_model = self.preset.tree_nodes[parent_id]
            for child_id in parent_model.children:
                m = self.preset.tree_nodes[child_id]
                label = m.name if m.type == "branch" else f"f {m.name}"
                tnode = parent_txt_node.add(label, expand=m.expanded)
                tnode.allow_expand = (m.type == "branch")
                tnode.data = child_id
                if m.type == "branch":
                    add_children(tnode, child_id)

        add_children(self.group_tree.root, self.preset.root_id)
        self.group_tree.show_root = True

        # 3) Compute the target index with optional offset and clamp
        if offset is None:
            target_idx = cur_idx
        else:
            target_idx = cur_idx + offset

        # 4) Select by index, auto-expanding ancestors so it's visible
        _tree_set_selected_by_idx(self.group_tree, target_idx, auto_expand=True, clamp=True)

    def populate_fields(self) -> None:
        self.fields.clear()
        for f in sorted(self.preset.fields.values(), key=lambda x: x.label.lower()):
            self.fields.append(FieldItem(f))

    # ---------- Event Handlers ----------

    def on_fields_list_start_drag(self, msg: FieldsList.StartDrag) -> None:
        if msg.field_id:
            self.dragging_field = msg.field_id
            self.dynamic.update(f"Drag: {msg.field_label} → drop on Tree to insert")

    def on_group_tree_drop_field(self, msg: GroupTree.DropField) -> None:
        # Insert dropped field under current selection in textual tree
        field_id = msg.field_id
        if not field_id:
            return
        tnode = self.group_tree.cursor_node or self.group_tree.root
        model_target_id = tnode.data if tnode.data else self.preset.root_id
        self.insert_field_under(model_target_id, field_id)
        self.populate_tree()
        self.dynamic.update(f"Inserted field '{field_id}' under '{self.preset.tree_nodes[model_target_id].name}'")

    # ---------- Actions ----------

    async def action_monitor(self) -> None:
        secs = self.preset.monitor_secs
        dev = self.preset.device
        if not dev:
            self.dynamic.update("No device set. Use 'd' to choose a device.")
            return
        self.dynamic.update(f"Monitoring ({secs}s...)")
        try:
            label_line, data_line = await self._capture_and_parse(dev, self.preset.baud, secs)
        except Exception as e:
            self.dynamic.update(f"Monitor error: {e}")
            return

        # Update fields registry only if we saw a label line with key: tokens
        if label_line:
            labels = self._extract_labels(label_line)
            for lab in labels:
                fid = lab
                if fid not in self.preset.fields:
                    self.preset.fields[fid] = FieldDef(id=fid, label=fid)
            self.populate_fields()

        # Update preview (no placeholder/auto labels)
        self.preset.last_preview = {"label_line": label_line, "data_line": data_line}
        self.preview.set_preview(label_line, data_line)
        self.dynamic.update("Monitor complete")

    def action_cycle_focus(self) -> None:
        # self.focus_next()
        self.update_context_help()

    def action_quit_confirm(self) -> None:
        self.dynamic.update("Quit? (y/N)")
        self.dynamic.interactive = True
        self._pending_quit = True
        self._pending_confirm = True

    def action_device_select(self) -> None:
        # Device selection UI in Dynamic pane (interactive)
        try:
            found = [p.device for p in list_ports.comports()]
        except Exception:
            found = []
        valid = found or ["/dev/ttyUSB0", "/dev/ttyUSB1", "/dev/ttyACM0", "COM3", "COM4"]
        current = self.preset.device or (valid[0] if valid else "")
        idx = valid.index(current) if current in valid else 0
        self._mode = "devsel"
        self._devsel = {"valid": valid, "index": idx}
        self._render_device_select()
        self.dynamic.interactive = True
        self.set_focus(self.dynamic)

    def action_save_preset(self) -> None:
        self.storage.save(self.preset)
        self.dynamic.update(f"Saved preset '{self.preset.name}'")

    # Tree actions (subset; wire rest as needed)
    def current_model_node(self) -> tuple[TextualTreeNode, ModelNode]:
        tnode = self.group_tree.cursor_node or self.group_tree.root
        mid = tnode.data if tnode.data else self.preset.root_id
        return tnode, self.preset.tree_nodes[mid]

    def action_tree_add_child(self) -> None:
        tnode, mnode = self.current_model_node()
        if mnode.type != "branch":
            return
        nid = new_id("b")
        new = ModelNode(id=nid, name=self.unique_child_name(mnode, "New"), type="branch", parent_id=mnode.id)
        self.preset.tree_nodes[nid] = new
        mnode.children.append(nid)
        self.populate_tree()

    def action_tree_add_sibling(self) -> None:
        tnode, mnode = self.current_model_node()
        if mnode.parent_id is None:
            return
        parent = self.preset.tree_nodes[mnode.parent_id]
        nid = new_id("b")
        new = ModelNode(id=nid, name=self.unique_child_name(parent, "New"), type="branch", parent_id=parent.id)
        self.preset.tree_nodes[nid] = new
        # insert after current
        idx = parent.children.index(mnode.id)
        parent.children.insert(idx + 1, nid)
        self.populate_tree()

    def action_tree_delete(self) -> None:
        tnode, mnode = self.current_model_node()
        if mnode.parent_id is None:
            self.dynamic.update("Cannot delete Root")
            return
        count = self.count_subtree(mnode.id)
        self.dynamic.update(f"Delete subtree '{mnode.name}' ({count} nodes)? (y/N)")
        self.dynamic.interactive = True
        self._pending_delete = mnode.id

    def action_tree_expand_one(self) -> None:
        # Expand the currently focused node (or root if none)
        node = self.group_tree.cursor_node or self.group_tree.root
        if node is not None:
            node.expand()

    def action_tree_expand_all(self) -> None:
        # Recursively expand the entire tree starting at root
        def rec(n):
            n.expand()
            for c in n.children:
                rec(c)
        rec(self.group_tree.root)

    def action_tree_collapse_one(self) -> None:
        # Collapse the currently focused node (or root if none)
        node = self.group_tree.cursor_node or self.group_tree.root
        if node is not None:
            node.collapse()

    def action_tree_collapse_all(self) -> None:
        # Recursively collapse the entire tree starting at root
        def rec(n):
            n.collapse()
            for c in n.children:
                rec(c)
        rec(self.group_tree.root)

    # --- Tree navigation helpers (replace cursor_down/cursor_up calls) ---
    def _visible_nodes(self):
        nodes = []
        def walk(n):
            nodes.append(n)
            if getattr(n, "expanded", False):
                for c in n.children:
                    walk(c)
        walk(self.group_tree.root)
        return nodes

    def _select_node(self, node):
        try:
            self.group_tree.select_node(node)
        except Exception:
            # Some Textual versions use action_select_node
            self.group_tree.action_select_node(node)

    def action_tree_down(self) -> None:
        current = self.group_tree.cursor_node or self.group_tree.root
        flat = self._visible_nodes()
        try:
            i = flat.index(current)
        except ValueError:
            i = 0
        if i < len(flat) - 1:
            self._select_node(flat[i + 1])

    def action_tree_up(self) -> None:
        self.dynamic.update(f"UP")
        current = self.group_tree.cursor_node or self.group_tree.root
        flat = self._visible_nodes()
        try:
            i = flat.index(current)
        except ValueError:
            i = 0
        if i > 0:
            self._select_node(flat[i - 1])

    async def _capture_and_parse(self, device: str, baud: int, seconds: int) -> tuple[str | None, str | None]:
        reader, _ = await serial_asyncio.open_serial_connection(url=device, baudrate=baud)
        loop = asyncio.get_running_loop()
        end = loop.time() + seconds
        
        best_label_line = None
        best_data_line = None
        
        try:
            # Discard any partial line that might be in the buffer
            try:
                await asyncio.wait_for(reader.readline(), timeout=0.1)
            except asyncio.TimeoutError:
                pass
                
            while loop.time() < end:
                try:
                    raw = await asyncio.wait_for(reader.readline(), timeout=0.2)
                except asyncio.TimeoutError:
                    continue
                if not raw:
                    continue
                    
                line = raw.decode(errors="ignore").rstrip("\r\n")
                if not line.strip():
                    continue
                    
                # Process this line immediately for labels
                if self._has_label_tokens(line):
                    best_label_line = line
                    labels = self._extract_labels(line)
                    # Update fields registry immediately
                    for lab in labels:
                        if lab not in self.preset.fields:
                            self.preset.fields[lab] = FieldDef(id=lab, label=lab)
                    # Update UI immediately
                    self.populate_fields()
                else:
                    # This is a data-only line
                    best_data_line = line
                    
        finally:
            try:
                reader.feed_eof()
            except Exception:
                pass

        return (best_label_line, best_data_line)


    def _find_label_line(self, lines: list[str]) -> str | None:
        for ln in lines:
            if self._has_label_tokens(ln):
                return ln
        return None

    def _find_data_line(self, lines: list[str]) -> str | None:
        for ln in reversed(lines):
            if not self._has_label_tokens(ln) and ln.strip():
                return ln
        return None

    def _has_label_tokens(self, line: str) -> bool:
        return bool(re.search(r"(?:^|\s)[^\s:]+\s*:", line))

    def _extract_labels(self, line: str) -> list[str]:
        return [m.group(1) for m in re.finditer(r"(?:^|\s)([^\s:]+)\s*:", line)]

    def action_tree_edit_or_insert(self) -> None:
        tnode, mnode = self.current_model_node()
        if mnode.type == "branch":
            # Start editing the branch name
            self._mode = "edit_name"
            self._edit_target = mnode.id
            self._edit_text = mnode.name
            self._edit_cursor = len(mnode.name)
            self.dynamic.update(f"Edit name: {self._edit_text}")
            self.dynamic.interactive = True
        else:
            self.dynamic.update("Leaf selected")

    # ---------- Insertion logic ----------

    def insert_field_under(self, target_model_id: str, field_id: str) -> None:
        target = self.preset.tree_nodes[target_model_id]
        # If target is a leaf, insert after it under its parent; if branch, insert as last child
        if target.type == "field":
            parent = self.preset.tree_nodes[target.parent_id] if target.parent_id else self.preset.tree_nodes[self.preset.root_id]
            nid = new_id("f")
            fnode = ModelNode(id=nid, name=self.preset.fields[field_id].label, type="field", parent_id=parent.id, field_id=field_id)
            self.preset.tree_nodes[nid] = fnode
            idx = parent.children.index(target.id)
            parent.children.insert(idx + 1, nid)
        else:
            nid = new_id("f")
            fnode = ModelNode(id=nid, name=self.preset.fields[field_id].label, type="field", parent_id=target.id, field_id=field_id)
            self.preset.tree_nodes[nid] = fnode
            target.children.append(nid)

    # ---------- Utilities ----------

    def unique_child_name(self, parent: ModelNode, base: str) -> str:
        existing = {self.preset.tree_nodes[c].name for c in parent.children}
        n = 1
        name = f"{base}-{n}"
        while name in existing:
            n += 1
            name = f"{base}-{n}"
        return name

    def count_subtree(self, node_id: str) -> int:
        def rec(nid: str) -> int:
            n = self.preset.tree_nodes[nid]
            return 1 + sum(rec(c) for c in n.children)
        return rec(node_id)

    # ---------- Global key routing to implement y/N confirms ----------

    def on_key(self, event: events.Key) -> None:
        if getattr(self.dynamic, "interactive", False):
            # if event.key == 'tab': # not working
            #     sys.exit()
            #     self.action_cycle_focus()
            # if self.focused is self.group_tree:
            if self._mode == "edit_name":
                if event.key == 'enter':
                    # Confirm edit
                    if self._edit_text.strip():
                        target_node = self.preset.tree_nodes[self._edit_target]
                        target_node.name = self._edit_text.strip()
                        self.preset.name = self._edit_text.strip()
                        self.populate_tree()
                        # self.dynamic.update(f"Renamed to '{self._edit_text.strip()}'")
                    else:
                        self.dynamic.update("Name cannot be empty")
                    self._mode = None
                    self.dynamic.interactive = False
                elif event.key == "escape":
                    # Cancel edit
                    self.dynamic.update("Edit cancelled")
                    self._mode = None
                    self.dynamic.interactive = False
                elif event.key == "backspace":
                    # Delete character
                    if self._edit_text:
                        self._edit_text = self._edit_text[:-1]
                        self.dynamic.update(f"Edit name: {self._edit_text}")
                elif len(event.key) == 1 and event.key.isprintable():
                    # Add character
                    self._edit_text += event.key
                    self.dynamic.update(f"Edit name: {self._edit_text}")
                else:
                    tree_node_count = len(self.preset.tree_nodes)
                    self.dynamic.update(f"DEBUG: Key pressed: {event.key!r} (Nodes: {tree_node_count})")
                event.prevent_default()
                # Consume all other keys
                return
            # --- Device select mode ---
            elif self._mode == "devsel":
                if event.key in ("up",):
                    if self._devsel and self._devsel["valid"]:
                        self._devsel["index"] = (self._devsel["index"] - 1) % len(self._devsel["valid"])
                        self._render_device_select()
                elif event.key in ("down",):
                    if self._devsel and self._devsel["valid"]:
                        self._devsel["index"] = (self._devsel["index"] + 1) % len(self._devsel["valid"])
                        self._render_device_select()
                elif event.key in ("enter",):
                    if self._devsel and self._devsel["valid"]:
                        choice = self._devsel["valid"][self._devsel["index"]]
                        self.preset.device = choice
                        self.header.device = choice
                        self.dynamic.update(f"Device set: {choice}")
                    self._mode = None
                    self._devsel = None
                    self.dynamic.interactive = False
                elif event.key in ("escape",):
                    self.dynamic.update("")
                    self._mode = None
                    self._devsel = None
                    self.dynamic.interactive = False
                elif event.key == "q":
                    # Exit device-select then forward to quit
                    self.dynamic.update("")
                    self._mode = None
                    self._devsel = None
                    self.dynamic.interactive = False
                    self.action_quit_confirm()
                else:
                    self.dynamic.update(f"DEBUG: Key pressed: {event.key!r}")
                event.prevent_default()
                return
            # --- Generic confirm mode (y/N) ---
            elif getattr(self, "_pending_confirm", False):
                # self.dynamic.update(f"DEBUG: Key pressed: {event.key!r}")
                if event.key == "y":
                    if getattr(self, "_pending_delete", False):
                        self._delete_subtree(self._pending_delete)
                        self._pending_delete = None
                        self.dynamic.update("Deleted.")
                    # elif self.dynamic.renderable and "Quit?" in str(self.dynamic.renderable):
                    # elif self.dynamic.renderable and getattr(self, "_pending_quit"):
                    elif getattr(self, "_pending_quit"):
                        self.exit()
                        return # let exit event be handled
                    self.dynamic.interactive = False
                    self._pending_confirm = False
                elif event.key in ('n','escape'):
                    self.dynamic.update("")
                    self.dynamic.interactive = False
                    if getattr(self, "_pending_quit", False):
                        self._pending_quit = False
                    self._pending_confirm = False
                self.dynamic.update(f"DEBUG: Key pressed: {event.key!r}")
                event.prevent_default()
                return

    def _delete_subtree(self, node_id: str) -> None:
        node = self.preset.tree_nodes[node_id]
        parent = self.preset.tree_nodes.get(node.parent_id) if node.parent_id else None
        # recursive delete
        def rec(nid: str):
            n = self.preset.tree_nodes[nid]
            for c in list(n.children):
                rec(c)
            self.preset.tree_nodes.pop(nid, None)
        rec(node_id)
        if parent:
            parent.children = [c for c in parent.children if c != node_id]
        self.populate_tree()

    def _render_device_select(self) -> None:
        if not self._devsel:
            return
        valid = self._devsel["valid"]
        idx = self._devsel["index"]
        if not valid:
            self.dynamic.update("No serial devices found. (Esc) to cancel")
            return
        line = " ".join(f"\\[{v}]" if i == idx else v for i, v in enumerate(valid))
        current = valid[idx]
        self.dynamic.update(f"{line}   \\[Current: {current}]  (Up/Down, Enter to set, Esc to cancel)")

    # ---------- Contextual help ----------

    def update_context_help(self) -> None:
        if self.focused is self.group_tree:
            self.update_help_for_tree()
        elif self.focused is self.fields:
            self.helpbar.update("(h/j) up/down   (Enter) Add to tree   (Drag) drop onto Tree")
        elif self.focused is self.dynamic and self._mode == "devsel":
            self.helpbar.update("Device select: (Up/Down) choose  (Enter) set  (Esc) cancel  (q) quit")
        else:
            self.helpbar.update("")


    def update_help_for_tree(self) -> None:
        self.helpbar.update("[Tab]  [Add: (a)Child (o)Sibling]  (e)Edit  (M)onitor  (h/H)collapse  (l/L)expand  (J/K)move  (Alt-j/k)reparent  (-)delete")

# ---------- CLI ----------

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-p", "--preset", default="default", help="Preset name")
    parser.add_argument("-l", "--list-presets", action="store_true")
    parser.add_argument("--config-dir", default=str(Path.home() / ".splotty-labels"))
    args = parser.parse_args()

    storage = Storage(Path(args.config_dir))
    if args.list_presets:
        for name in storage.list_presets():
            print(name)
        return

    app = LabelManagerApp(args.preset, Path(args.config_dir))
    app.run()

if __name__ == "__main__":
    main()

# vim: et
