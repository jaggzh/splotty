#!/usr/bin/perl
#!/usr/bin/perl -d
# splotty: Serial-data Text-based Plotter
my $VERSION="0.2b";

# keep -d for forced debug on

# Use this to set a breakpoint (to return the term)
#    restore_tty(); show_cursor(); $DB::single=1; set_raw_tty(); $need_redraw=1; hide_cursor();

BEGIN { if (grep {/--debug/} @ARGV) { my @ARGS=grep {!/--debug/} @ARGV; exec($^X, "-d", __FILE__, @ARGS); } }
use v5.36;
use utf8;
use Getopt::Long;
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use FindBin;
use lib "$FindBin::RealBin/lib";
use String::ShortcutsAuto qw(assign_shortcuts);
use YAML::XS qw(LoadFile DumpFile Dump);
use File::Slurper qw(write_text);
use File::HomeDir;
use File::Path qw(make_path);
use File::Spec;
use Cwd 'abs_path';
use Time::HiRes qw(gettimeofday);
use POSIX qw(strftime);
use Data::Dumper;
use List::Util 'shuffle';
use File::Spec;

binmode STDOUT, ':encoding(UTF-8)';

# ---------------- CLI ----------------
my %opt = (
    header   => 2,     # minimum header lines; will be dynamic
    footer   => 1,     # minimum footer lines; will be calculated
    series   => 4,     # how many fields (series) - will be dynamic with serial
    window   => 30,    # autorange window (rows) across all series
    delay_ms => 0,     # inter-row delay in ms; default off (0)
    no_color => 0,     # disable color
    serial_port => '/dev/ttyACM1',  # default serial port
    baud_rate => 115200,            # default baud rate
    demo_mode => 0,                 # use fake data instead of serial
    stdin_mode => 0,                # read data from stdin
    cmd => '',                      # command to execute and read from
    fieldspec => '',                # fieldspec YAML file
    wipe      => 0,                 # wipe our stored fieldspec path
    force     => 0,                 # force run, ignoring fieldspec path
    version   => 0,                 # show version
    help => 0,                      # show help
    no_enter_ends_input => 0,       # Default is a blank enter exits Send mode
);
my $logfile_debug = "log.splotty.txt";

sub show_help {
    print <<"EOF";
splotty: Serial-data Text-based Plotter

USAGE:
    splotty [OPTIONS]

OPTIONS:
    --header=N          Minimum header lines (default: 2)
    --footer=N          Minimum footer lines (calculated dynamically)
    --series=N          Initial number of series (default: 4, auto-detected)
    --window=N          Autorange window in rows (default: 30)
    --delay_ms=N        Inter-row delay in milliseconds (default: 0)
    --no-color          Disable color output
    --serial-port=PATH  Serial port path (default: /dev/ttyACM1)
    --baud-rate=N       Baud rate (default: 115200)
    --fieldspec=FILE    Load field specification YAML file
    -f FILE             Short form of --fieldspec
    --wipe              Wipe stored fieldspec path
    --force             Force run, ignoring a bad fieldspec path
    --help              Show this help
    --version           Show version and quit
    --log               Log debug info to $logfile_debug
    --no-enter-ends-input  Default is that a blank enter ends input mode
                           (send to serial) instead of just ^T again.

DATA SOURCE MODES (mutually exclusive):
    --demo              Generate random demo data
    --stdin             Read data from stdin (keyboard input from /dev/tty)
    --cmd=COMMAND       Read data from command output
    (default)           Read data from serial port

CONTROLS (in plotter):
    q                   Quit
    N                   Toggle inline numbers on plot points
    ^T                  Toggle terminal input mode (send data to serial
                          - serial mode only)
    ^D                  Toggle raw serial output window
    +/-                 Resize raw output window (when active)
    [field keys]        Toggle individual fields (defined in fieldspec)
    [group keys]        Toggle field groups (defined in fieldspec)

FIELDSPEC FORMAT:
    YAML file defining groups, fields, colors, and keyboard shortcuts.
    See example fields.yaml for format details.

EXAMPLES:
    splotty --demo                          # Demo mode
    splotty -f fields.yaml                  # Load field configuration
    splotty --serial-port=/dev/ttyUSB0      # Different serial port
    splotty -f fields.yaml --demo           # Demo with field config
    cat data.txt | splotty --stdin          # Read from pipe
    splotty --cmd="./sensor-reader"         # Read from command
EOF
    exit 0;
}

GetOptions(
    'header=i'      => \$opt{header},
    'footer=i'      => \$opt{footer},
    'series=i'      => \$opt{series},
    'window=i'      => \$opt{window},
    'delay_ms|d=i'  => \$opt{delay_ms},
    'no-color!'     => \$opt{no_color},
    'serial-port|p=s' => \$opt{serial_port},
    'baud-rate|r=i'   => \$opt{baud_rate},
    'demo!'         => \$opt{demo_mode},
    'stdin!'        => \$opt{stdin_mode},
    'cmd=s'         => \$opt{cmd},
    'fieldspec|f=s' => \$opt{fieldspec},
    'wipe'          => \$opt{wipe},
    'force'         => \$opt{force},
    'help|h'        => \$opt{help},
    'version'       => \$opt{version},
    'log'           => \$opt{log},
    'no-enter-ends-input' => \$opt{no_enter_ends_input},
) or die "Bad options. Use --help for usage information.\n";

show_help() if $opt{help};
if ($opt{version}) {
    print "Splotty version: $VERSION\n";
    exit;
}

# Check for mutually exclusive data source options
my $mode_count = ($opt{demo_mode} ? 1 : 0) + ($opt{stdin_mode} ? 1 : 0) + ($opt{cmd} ? 1 : 0);
die "Cannot use --demo, --stdin, and --cmd together. Choose only one data source.\n" if $mode_count > 1;

# ---------------- Data Source Configuration ----------------
my $data_source_type = '';  # 'demo', 'stdin', 'cmd', 'serial'
my $data_fh;                # Active data source filehandle
my $data_buffer = '';       # Data accumulation buffer for line-oriented reading

# ---------------- Configuration & State Management ----------------
my $config_dir = File::Spec->catdir(File::HomeDir->my_home, '.config', 'splotty');
my $state_file = File::Spec->catfile($config_dir, 'state.yaml');

my %fieldspec = ();          # Loaded fieldspec configuration
my %group_states = ();       # Current group on/off states
my %field_states = ();       # Current field on/off states
my %field_shortcuts = ();    # Field name -> keyboard shortcut
my %group_shortcuts = ();    # Group name -> keyboard shortcut
my %shortcut_to_field = ();  # Reverse mapping: shortcut -> field name
my %shortcut_to_group = ();  # Reverse mapping: shortcut -> group name
my $fieldspec_path = '';     # Resolved path to current fieldspec
my $input_underscore = '🥕';

# ---------------- Layout state ----------------
my ($ROWS, $COLS) = term_size();
my $need_redraw = 1;       # trigger full redraw
my $need_redraw_msg = '';  # Reason for redraw
my $need_redraw_line = 0;  # Line of redraw requester
my $inline_nums_on = 0;  # toggle with 'N' to show/hide per-glyph sensor numbers
my $min_plot_height = 6;
my $debug_msg = "";      # debug message for footer
my $input_active = 0;    # whether terminal input line is active
my $input_buffer = "";   # current input buffer
my $input_cursor = 0;    # cursor position in input buffer

# Layout calculations
my ($actual_header_lines, $actual_footer_lines, $legend_lines_needed);
my ($plot_top, $plot_bottom, $plot_height, $plot_left, $plot_right, $plot_width);
my ($legend_start_row);
my $raw_output_active = 0;  # whether raw serial output area is active
my $raw_output_height = 0;  # height of raw output area
my $raw_output_top = 0;     # top row of raw output area
my $raw_output_bottom = 0;  # bottom row of raw output area
my @plot_data_buffer = ();  # buffer plot data when raw output is active

# gutters
my $yaxis_w   = 0;       # pure char plotting; no X/Y axes in the scroller row lines
my $pad_left  = 1;       # small left pad
my $pad_right = 1;       # small right pad

# glyphs/colors
# my @glyphs = ('●','◆','■','▲','○','◇','□','△','▣','▵','✶','✦','▸','◆','◼','▴');
# my @colors = (196,208,220,40,45,51,201,190,33,129,99,178,75,141,214,160);
my @glyphs = (
    '●','◆','■','▲','○','◇','□','△','▣','✶','✦','▸','◼','▴',
    '♦','♠','♣','♥','★','☆','◉','◎','⬢','⬡','⬣','⬤','⬟','⚬','◘','◙',
    '±','∞','∆','∇','※','‡','†','¤','⊙','⊚','⊛','⊜','⊝','⊞','⊟',
    '►','◄','▼','▶','◊','╳','╬','┼','▪','▫','▬','▭','▮','▯','▰','▱',
    '⟐','⟡','♪','♫','⌘','⊠','⊡','⟢','⟣','⟤','⟥','⟦','⟧','◣',
    '◤','◥','◢','◐','◑','◒','◓','⬰','⬱','⬲','⬳','⭘','⭙','⭚','⭛','⭜'
);

my @colors = (
    196,208,220,40,45,51,201,190,33,129,99,178,75,141,214,160,
    124,197,198,202,203,209,210,211,
    46,47,48,76,82,83,118,154,156,191,192,
    12,19,20,21,26,27,32,38,39,68,69,74,104,105,110,140,146,147,176,177,182,183,212,213,218,219,
    11,184,221,222,226,227,228,
    135,165,171,177,207,213,219,225,
    14,50,86,87,122,158,195,97
);

# ---------------- Data ----------------
my $S = $opt{series};
my @values;          # current values (length S)
my @field_names;     # field names for each series
my @hist;            # history ring buffers per series (array of arrayrefs)
my $hsize = $opt{window};

# For demo mode - keep the original random data
my @start = map { 50 + rand()*50 } (1..$S);
my @vol   = map { 6 + rand()*6 }   (1..$S);

# ---------------- Field Stability System ----------------
my %field_configs;       # track different field configurations
my $current_config_key = "";
my $config_stability_count = 0;
my $min_stability_count = 3;  # need to see config this many times before changing
my $max_recent_configs = 10;   # keep track of recent configs

my $cleaned = 0; # Clean-up flag for shutting down

my $sleep_s = ($opt{delay_ms} // 0) / 1000.0;
my $legend_update_counter = 0;
# Open keyboard input source based on mode
my $kb_input_fh;

sub millis() {
    my ($s, $usec) = gettimeofday();
    my $ms = $s*1000 + int($usec/1000);
    return $ms;
}

sub log_debug($msg) {
    return if !$opt{log};
    my ($t, $usec) = gettimeofday();
    my $ms = int($usec/1000);
    my $ts = sprintf "%s.%03d",
        strftime("%H:%M:%S", localtime($t)),
        $ms;

    open(my $lf, ">>", $logfile_debug) || die "Couldn't open log $logfile_debug: $!";
    say $lf "[$ts] $msg";
    close $lf;
}

sub get_config_dir {
    make_path($config_dir) unless -d $config_dir;
    return $config_dir;
}

sub load_state {
    return unless -f $state_file;

    eval {
        my $state = LoadFile($state_file);

        # Load last used serial settings if not specified on command line
        if ($state->{last_state}) {
            if (!defined $ARGV[0] || !grep { /--serial-port/ } @ARGV) {
                if ($state->{last_state}->{serial_port}) {
                    $opt{serial_port} = $state->{last_state}->{serial_port};
                }
            }
            if (!grep { /--baud-rate/ } @ARGV) {
                if ($state->{last_state}->{baud_rate}) {
                    $opt{baud_rate} = $state->{last_state}->{baud_rate};
                }
            }
        }

        # Load last used fieldspec if no fieldspec specified
        if (!$opt{fieldspec} && $state->{last_state} && $state->{last_state}->{fieldspec_path}) {
            $opt{fieldspec} = $state->{last_state}->{fieldspec_path};
        }

        # Load saved states if using same fieldspec
        if ($state->{last_state} &&
            $state->{last_state}->{fieldspec_path} eq abs_path($opt{fieldspec} // '')) {
            %group_states = %{$state->{last_state}->{groups} // {}};
            %field_states = %{$state->{last_state}->{fields} // {}};
        }
    };
    warn "Failed to load state: $@" if $@;
}

sub save_state {
    get_config_dir();  # Ensure directory exists
    my $state = {};

    $state = {
        last_state => {
            fieldspec_path => $fieldspec_path,
            groups => \%group_states,
            fields => \%field_states,
            serial_port => $opt{serial_port},
            baud_rate => $opt{baud_rate},
        }
    };

    eval {
        DumpFile($state_file, $state);
    };
    warn "Failed to save state: $@" if $@;
}

sub load_fieldspec {
    my ($file) = @_;
    return unless $file && -f $file;

    eval {
        %fieldspec = %{LoadFile($file)};
        $fieldspec_path = abs_path($file);

        # Initialize group states from fieldspec
        if ($fieldspec{groups}) {
            for my $group_name (keys %{$fieldspec{groups}}) {
                my $group = $fieldspec{groups}->{$group_name};
                $group_states{$group_name} //= $group->{state} // 1;

                $group->{key} //= 'auto';
                if ($group->{key} ne 'auto') {
                    $group_shortcuts{$group_name} = $group->{key};
                    $shortcut_to_group{$group->{key}} = $group_name;
                }
            }
        }

        # Initialize field states and collect manual shortcuts (skip hidden fields)
        my %manual_field_shortcuts;
        if ($fieldspec{fields}) {
            for my $field_name (keys %{$fieldspec{fields}}) {
                my $field = $fieldspec{fields}->{$field_name};

                # Skip hidden fields - they don't get state or shortcuts
                next if $field->{hidden};

                # Field starts with global start state, then affected by groups
                my $start_state = $fieldspec{state}->{start} // 1;
                $field_states{$field_name} //= $start_state;

                if (!exists $$field{key}) {
                    if ( ! exists $fieldspec{defaults}{fields}{key_auto}
                            || $fieldspec{defaults}{fields}{key_auto}) {
                        $$field{key} = 'auto';
                    }
                } elsif ($field->{key} && $field->{key} ne 'auto') {
                    $manual_field_shortcuts{$field_name} = $field->{key};
                }
            }
        }

        # Apply group states to fields in order
        apply_group_states_to_fields();

        # Auto-assign shortcuts for 'auto' fields and groups
        assign_auto_shortcuts(\%manual_field_shortcuts);

        set_debug("Loaded fieldspec: $file");
    };

    if ($@) {
        my $err = <<~"EOT";
            Failed to load fieldspec '$file': $@
            Use --wipe to clear it from our state file at:
              $state_file
            Use --force to just run, ignoring the fieldspec file
            EOT
        if ($opt{force} || $opt{wipe}) {
            swarn($err);
        }
        if ($opt{wipe}) {
            $fieldspec_path = '';
            save_state();
            swarn("Wiped.");
            exit 0;
        } elsif (!$opt{force}) {
            swarn($err);
            exit 1;
        }
        return;
    }

    return 1;
}

sub apply_group_states_to_fields {
    return unless $fieldspec{groups} && $fieldspec{fields};

    # Get groups sorted by order
    my @ordered_groups = sort {
        ($fieldspec{groups}->{$a}->{order} // 999) <=>
        ($fieldspec{groups}->{$b}->{order} // 999)
    } keys %{$fieldspec{groups}};

    # Apply group states to their fields (skip hidden fields)
    for my $group_name (@ordered_groups) {
        my $group_state = $group_states{$group_name};

        for my $field_name (keys %{$fieldspec{fields}}) {
            my $field = $fieldspec{fields}->{$field_name};
            next if $field->{hidden};  # Skip hidden fields

            my $field_groups = $field->{groups} // [];

            if (grep { $_ eq $group_name } @$field_groups) {
                $field_states{$field_name} = $group_state;
            }
        }
    }
}

sub assign_auto_shortcuts {
    my ($manual_field_shortcuts) = @_;

    # Collect all strings that need auto-assignment
    my @auto_fields = ();
    my @auto_groups = ();

    # Find auto fields (skip hidden fields)
    if ($fieldspec{fields}) {
        for my $field_name (keys %{$fieldspec{fields}}) {
            my $field = $fieldspec{fields}->{$field_name};
            next if $field->{hidden};  # Skip hidden fields

            if (($field->{key} // '') eq 'auto') {
                push @auto_fields, $field_name;
            }
        }
    }

    # Also include field_names that aren't in fieldspec at all (dynamic fields)
    for my $field_name (@field_names) {
        next if is_field_hidden($field_name);  # Skip hidden fields
        # If field isn't in fieldspec, it needs auto-assignment
        if (!exists $fieldspec{fields} || !exists $fieldspec{fields}->{$field_name}) {
            push @auto_fields, $field_name unless grep { $_ eq $field_name } @auto_fields;
        }
    }

    # Find auto groups
    if ($fieldspec{groups}) {
        for my $group_name (keys %{$fieldspec{groups}}) {
            my $group = $fieldspec{groups}->{$group_name};
            if (($group->{key} // '') eq 'auto') {
                push @auto_groups, $group_name;
            }
        }
    }

    # Collect excluded keys (UI keys + manual assignments)
    my @exclude = ('q', 'N', 'Q');  # Reserved UI keys
    push @exclude, values %$manual_field_shortcuts;
    push @exclude, values %group_shortcuts;

    # Assign shortcuts for auto fields
    if (@auto_fields) {
        my %auto_field_shortcuts = assign_shortcuts(
            strings => \@auto_fields,
            exclude => \@exclude,
            manual => {},
        );

        for my $field_name (@auto_fields) {
            if (defined( my $key = $auto_field_shortcuts{$field_name} )) {
                $field_shortcuts{$field_name} = $key;
                $shortcut_to_field{$key} = $field_name;
                push @exclude, $key;
            }
        }
    }

    # Assign shortcuts for auto groups
    if (@auto_groups) {
        my %auto_group_shortcuts = assign_shortcuts(
            strings => \@auto_groups,
            exclude => \@exclude,
            manual => {},
        );

        for my $group_name (@auto_groups) {
            if (defined( my $key = $auto_group_shortcuts{$group_name})) {
                $group_shortcuts{$group_name} = $key;
                $shortcut_to_group{$key} = $group_name;
            }
        }
    }

    # Add manual field shortcuts
    for my $field_name (keys %$manual_field_shortcuts) {
        my $key = $manual_field_shortcuts->{$field_name};
        $field_shortcuts{$field_name} = $key;
        $shortcut_to_field{$key} = $field_name;
    }
}

sub apply_single_group_to_fields {
    my ($target_group_name) = @_;
    return unless $fieldspec{groups} && $fieldspec{fields};
    return unless exists $group_states{$target_group_name};

    my $group_state = $group_states{$target_group_name};

    # Apply this group's state to its fields only (skip hidden fields)
    for my $field_name (keys %{$fieldspec{fields}}) {
        my $field = $fieldspec{fields}->{$field_name};
        next if $field->{hidden};  # Skip hidden fields

        my $field_groups = $field->{groups} // [];

        if (grep { $_ eq $target_group_name } @$field_groups) {
            $field_states{$field_name} = $group_state;
        }
    }
}

sub toggle_group {
    my ($group_name) = @_;
    return unless exists $group_states{$group_name};

    $group_states{$group_name} = !$group_states{$group_name};
    apply_single_group_to_fields($group_name);  # Only apply this specific group
    set_debug("Toggled group '$group_name' to " . ($group_states{$group_name} ? 'ON' : 'OFF'));
}

sub toggle_field {
    my ($field_name) = @_;
    return unless exists $field_states{$field_name};

    $field_states{$field_name} = !$field_states{$field_name};
    set_debug("Toggled field '$field_name' to " . ($field_states{$field_name} ? 'ON' : 'OFF'));
}

sub is_field_enabled {
    my ($field_name) = @_;
    return $field_states{$field_name} // 1;
}

sub is_field_hidden {
    my ($field_name) = @_;
    my $config = get_field_config($field_name);
    return $config->{hidden} // 0;
}

sub get_field_config {
    my ($field_name) = @_;
    return $fieldspec{fields}->{$field_name} // {};
}

# ---------------- Term & ANSI helpers ----------------
my $cur_area = '';
my $cur_plot_top;

sub esc  { "\e[" . shift }
sub gotorc { my ($r,$c)=@_; sprintf "\e[%d;%dH",$r,$c }
sub clr_eol { esc("K") }
sub hide_cursor { print esc("?25l") }
sub show_cursor { print esc("?25h") }
sub set_scroll_region { my ($top,$bot)=@_; print esc("${top};${bot}r") }
sub reset_scroll_region { print esc("r"); $cur_area = ''; }
sub a_rst { esc("0m") }
sub fg256 { my ($n)=@_; $opt{no_color} ? "" : esc("38;5;${n}m") }
sub bg256 { my ($n)=@_; $opt{no_color} ? "" : esc("48;5;${n}m") }
sub fg24 { my ($r,$g,$b)=@_; $opt{no_color} ? "" : esc("38;2;${r};${g};${b}m") }
sub bg24 { my ($r,$g,$b)=@_; $opt{no_color} ? "" : esc("48;2;${r};${g};${b}m") }
sub bold { $opt{no_color} ? "" : esc("1m") }
sub a_raw_area { bg256(17) }

# Color definitions for field name highlighting
sub a_fieldname { fg256(253); }  # Normal field name color
sub a_fieldname_disabled { $opt{no_color} ? "" : fg256(244) }  # Dimmed for disabled fields
sub a_hotkey { $opt{no_color} ? "" : fg256(206) }  # Bright yellow for hotkey
sub a_warn { esc("33;1m") }
my $a_header_bg = bg256(237);
my $a_footer_bg = bg24(0,0,90);
my $a_legend_bg = bg24(0,0,40);
my $a_whi = esc("37;1m");
my $a_input = bg256(24) . $a_whi;

sub swarn {
    print STDERR a_warn(), @_, a_rst();
}
sub ds {
    print Dumper(shift);
}

sub term_size {
    my ($rows,$cols) = (undef, undef);
    eval {
        require "sys/ioctl.ph";            ## no critic
        my $winsize = pack('S4', 0,0,0,0);
        ioctl(STDOUT, &TIOCGWINSZ, $winsize) or die;
        ($rows,$cols) = unpack('S4', $winsize);
        1;
    } or do {
        my $sz = `stty size 2>/dev/null`;
        ($rows,$cols) = ($1,$2) if $sz =~ /(\d+)\s+(\d+)/;
    };
    $rows ||= 24; $cols ||= 80;
    return ($rows,$cols);
}

sub set_need_redraw($msg, $lineno=undef) {
    my ($package, $filename, $line) = caller();
    $need_redraw_msg = $msg;
    $need_redraw_line = $lineno // $line;
    $need_redraw=1;
}

sub get_config_key {
    my ($names) = @_;
    return join('|', @$names);
}

sub update_field_stability {
    my ($new_names, $new_values) = @_;

    my $config_key = get_config_key($new_names);

    # Track this configuration
    $field_configs{$config_key}++;

    # Clean up old configs if we have too many
    if (keys %field_configs > $max_recent_configs) {
        # Remove configs with lowest counts
        my @sorted_configs = sort { $field_configs{$a} <=> $field_configs{$b} } keys %field_configs;
        while (keys %field_configs > $max_recent_configs) {
            my $to_remove = shift @sorted_configs;
            delete $field_configs{$to_remove};
        }
    }

    # Check if this is the same as current config
    if ($config_key eq $current_config_key) {
        $config_stability_count++;
    } else {
        # Different config - check if it has enough stability
        if ($field_configs{$config_key} >= $min_stability_count) {
            my $legend_line_count_prev = calculate_legend_lines_needed();
            # This config is stable enough, switch to it
            $current_config_key = $config_key;
            $config_stability_count = $field_configs{$config_key};

            # Actually update the fields
            @field_names = @$new_names;
            $S = @field_names;
            @values = @$new_values;
            @hist = map { [] } (0..$S-1);

            # Initialize field states for new fields (if not already set)
            for my $field_name (@field_names) {
                next if exists $field_states{$field_name};  # Already has state
                my $start_state = 1;  # Default to enabled
                if (%fieldspec && $fieldspec{state} && exists $fieldspec{state}->{start}) {
                    $start_state = $fieldspec{state}->{start};
                }
                $field_states{$field_name} = $start_state;
            }

            # Re-assign shortcuts for all fields (including new dynamic fields)
            my %manual_field_shortcuts;
            if ($fieldspec{fields}) {
                for my $field_name (keys %{$fieldspec{fields}}) {
                    my $field = $fieldspec{fields}->{$field_name};
                    next if $field->{hidden};
                    if ($field->{key} && $field->{key} ne 'auto') {
                        $manual_field_shortcuts{$field_name} = $field->{key};
                    }
                }
            }
            assign_auto_shortcuts(\%manual_field_shortcuts);

            # Determine if we can avoid redrawing the whole screen
            my $legend_line_count_new = calculate_legend_lines_needed();
            if ($legend_line_count_new != $legend_line_count_prev) {
                set_need_redraw("Field count changed (to " . scalar(@field_names) . "). Stability: $config_stability_count");
            } else {
                draw_legend();
            }
            log_debug(join(", ", @$new_names));
            return 1;  # indicate change happened
        } else {
            # Not stable enough yet, keep current config but update debug
            set_debug("New config seen: " . join(", ", @$new_names) . " (count: " . $field_configs{$config_key} . "/$min_stability_count)");
            return 0;  # no change
        }
    }

    # Same config, just update values
    if (@field_names > 0) {  # only if we have established fields
        @values = @$new_values;
        return 1;  # indicate data was updated
    }

    return 0;
}

sub write_fieldspec_template {
    return if $S == 0;  # No fields to write
    my $header = <<~EOT;
        # splotty fieldspec template YAML
        #   Auto-generated
        # groups:
        #   # Name of group (eg. "All")
        #   All:
        #     # key: Optional key (instead of auto)
        #     key: "A"
        #     # state: Starting state of whole group.
        #     state: true
        #     # order: Order in which state applied.
        #     order: 0
        #   Something:
        #     key: "S"
        #     state: false
        #     order: 0
        # state:
        #   # start: true by default (all fields start enabled)
        #   start: true
        # fields:
        #   some_field_name:
        #     # groups: [list of groups this field belongs to]
        #     groups: ["All", "Something"]
        #   another:
        #     groups: ["All"]
        #     # start: starting state of field
        #     # hidden: don't show in ui
        #     # key_auto: defaults to true
        #     start: 0
        #     hidden: true
        #     key_auto: false
        EOT

    my $tmpdir = File::Spec->tmpdir();
    my $timestamp = strftime("%H%M%S", localtime);
    my $filename = File::Spec->catfile($tmpdir, "splotty-fields-$timestamp.yaml");

    # Build a minimal fieldspec structure
    my %spec = (
        defaults => {
            fields => {
                key_auto => 1,
            }
        },
        state => {
            start => 1,
        },
        fields => {},
    );

    # Add each field
    for my $i (0..$S-1) {
        my $field_name = $field_names[$i] // ($i + 1);
        next if is_field_hidden($field_name);  # Skip hidden fields

        my $config = get_field_config($field_name);

        # Build field entry
        my %field_entry = (
            # key => 'auto',
            groups => ['All'],
        );

        # Include current glyph and color if different from defaults
        my $default_glyph = $glyphs[$i % @glyphs];
        my $default_color = $colors[$i % @colors];
        my $current_glyph = $config->{ch} // $default_glyph;
        my $current_color = $config->{fg} // $default_color;

        $field_entry{ch} = $current_glyph if $current_glyph ne $default_glyph;
        $field_entry{fg} = $current_color if $current_color != $default_color;

        # Add RGB color if present
        if ($config->{fg24}) {
            $field_entry{fg24} = $config->{fg24};
            delete $field_entry{fg};  # Remove 256-color if RGB is present
        }

        $spec{fields}{$field_name} = \%field_entry;
    }

    # Write the file
    eval {
        my $yaml = Dump(\%spec);
        write_text($filename, "$header$yaml");
        set_debug("Wrote fieldspec template to: $filename");
    };

    if ($@) {
        set_debug("Failed to write fieldspec: $@");
    }
}

# ---------------- Serial Data ----------------
my $serial_buffer = '';

sub open_data_source {
    # Determine data source type
    if ($opt{demo_mode}) {
        $data_source_type = 'demo';
        set_debug("Using demo mode");
        return;
    } elsif ($opt{stdin_mode}) {
        $data_source_type = 'stdin';
        $data_fh = *STDIN;

        # Make stdin non-blocking
        my $flags = fcntl($data_fh, F_GETFL, 0) or die "fcntl F_GETFL on stdin: $!\n";
        fcntl($data_fh, F_SETFL, $flags | O_NONBLOCK) or die "fcntl F_SETFL on stdin: $!\n";

        set_debug("Reading data from stdin");
    } elsif ($opt{cmd}) {
        $data_source_type = 'cmd';

        # Open command for reading
        open($data_fh, "-|", $opt{cmd}) or die "Cannot execute command '$opt{cmd}': $!\n";

        # Make command pipe non-blocking
        my $flags = fcntl($data_fh, F_GETFL, 0) or die "fcntl F_GETFL on command pipe: $!\n";
        fcntl($data_fh, F_SETFL, $flags | O_NONBLOCK) or die "fcntl F_SETFL on command pipe: $!\n";

        set_debug("Reading data from command: $opt{cmd}");
    } else {
        # Default to serial port
        $data_source_type = 'serial';
        open_serial_port();
    }
}

sub open_serial_port {
    my $port = $opt{serial_port};
    my $baud = $opt{baud_rate};

    # Configure the serial port using stty
    system("stty -F $port $baud cs8 -cstopb -parity raw -echo") == 0
        or die "Failed to configure serial port $port: $!\n";

    # Open the serial port or file
    open($data_fh, '+<', $port) or die "Cannot open serial port $port: $!\n";

    # Make it non-blocking
    my $flags = fcntl($data_fh, F_GETFL, 0) or die "fcntl F_GETFL: $!\n";
    fcntl($data_fh, F_SETFL, $flags | O_NONBLOCK) or die "fcntl F_SETFL: $!\n";

    set_debug("Opened $port at $baud baud");
}

sub read_data_source {
    return unless $data_fh || $data_source_type eq 'demo';
    return if $data_source_type eq 'demo';  # Demo data generated elsewhere

    my $data;
    my $bytes_read = sysread($data_fh, $data, 1024);
    return unless defined $bytes_read && $bytes_read > 0;

    $data_buffer .= $data;

    my @lines;
    while ($data_buffer =~ s/^([^\n]*)\n//) {
        my $line = $1;
        $line =~ s/\r//g;  # remove carriage returns
        push @lines, $line;
    }

    return @lines;
}

sub send_serial_data {
    my ($data) = @_;
    return unless $data_fh;

    # Check if we're in a mode that supports sending
    if ($data_source_type ne 'serial') {
        set_debug("Send not supported in $data_source_type mode");
        return;
    }

    # Add newline if not present
    $data .= "\n" unless $data =~ /\n$/;

    eval {
        print $data_fh $data;
        $data_fh->flush() if $data_fh->can('flush');
    };

    if ($@) {
        set_debug("Send error: $@");
    } else {
        set_debug("Sent: " . substr($data, 0, 40) . (length($data) > 40 ? "..." : ""));
    }
}

sub output_raw_line {
    my ($line) = @_;

    # Convert tabs to two spaces
    $line =~ s/\t/  /g;

    setup_raw_output_scroll();
    print gotorc($raw_output_bottom, 1);
    $line =~ s/\n$//;
    print a_raw_area() . "\n" . $line . a_rst();
}

sub clear_raw_output_area {
    return unless $raw_output_active;

    for my $r ($raw_output_top..$raw_output_bottom) {
        print gotorc($r, 1), a_raw_area() . clr_eol() . a_rst();
    }
}

sub setup_raw_output_scroll {
    if ($raw_output_active) {
        if ($cur_area ne 'raw') {
            set_scroll_region($raw_output_top, $raw_output_bottom);
        }
        $cur_area = 'raw';
    }
}

sub setup_plot_output_scroll {
    if ($cur_area ne 'plot') {
        set_scroll_region($cur_plot_top, $plot_bottom);
        $cur_area = 'plot';
    }
}

sub replay_history {
    return if $S == 0;  # No data yet

    # Find the minimum history depth across all series
    my $history_depth = 0;
    for my $i (0..$S-1) {
        my $depth = scalar @{$hist[$i]};
        $history_depth = $depth if $history_depth == 0 || $depth < $history_depth;
    }

    return if $history_depth == 0;  # No history to replay

    # Replay min(history_depth, plot_height) rows
    my $rows_to_replay = $history_depth < $plot_height ? $history_depth : $plot_height;
    my $start_idx = $history_depth - $rows_to_replay;

    # Calculate range for the entire history we're replaying
    my ($vmin, $vmax) = window_minmax();

    # Temporarily disable scrolling to place rows directly
    reset_scroll_region();

    # Save current values
    my @saved_values = @values;

    for my $row_idx (0..$rows_to_replay-1) {
        my $hist_idx = $start_idx + $row_idx;
        my $screen_row = $cur_plot_top + $row_idx;

        # Set values to this historical point
        for my $i (0..$S-1) {
            $values[$i] = $hist[$i]->[$hist_idx] if $hist_idx < @{$hist[$i]};
        }

        my $row = build_plot_row($vmin, $vmax);
        print gotorc($screen_row, 1), $row, clr_eol();
    }

    # Restore current values and scrolling
    @values = @saved_values;
    setup_plot_output_scroll();
}

sub init_data {
    if ($data_source_type eq 'demo') {
        # Initialize demo data
        @field_names = map { "f$_" } (1..$S);
        $current_config_key = get_config_key(\@field_names);
        $config_stability_count = $min_stability_count;
        for my $i (0..$S-1) {
            $values[$i] = $start[$i];
            $hist[$i]   = [];
        }
    } else {
        # Initialize empty for piped/serial data
        @values = ();
        @field_names = ();
        @hist = ();
        $S = 0;
        $current_config_key = "";
        $config_stability_count = 0;
    }
}

sub parse_arduino_line {
    my ($line) = @_;
    chomp $line;
    $line =~ s/\s+$//;  # strip trailing whitespace

    my @fields = split /\s+/, $line;
    my (@names, @vals);

    for my $i (0..$#fields) {
        my $field = $fields[$i];
        if ($field =~ /^([^: ]+):([+-]?(?:\d+\.?\d*|\.\d+))$/) {
            # Has label: "label:value"
            push @names, $1;
            push @vals, $2 + 0;  # convert to number
        } elsif ($field =~ /^([+-]?(?:\d+\.?\d*|\.\d+))$/) {
            # No label, just value: "value"
            push @names, ($i + 1);  # 1-indexed field number
            push @vals, $1 + 0;
        } else {
            return ([],[]); # Return nothing on any invalid data
        }
    }

    return (\@names, \@vals);
}

sub update_fields {
    my ($new_names, $new_values) = @_;

    my $data_updated = update_field_stability($new_names, $new_values);

    if ($data_updated && @field_names > 0) {
        # Update history
        for my $i (0..$S-1) {
            push @{$hist[$i]}, $values[$i];
            shift @{$hist[$i]} while @{$hist[$i]} > $hsize*3;
        }

        # Recompute layout
        recompute_layout();
    }

    return $data_updated;
}

sub recompute_layout {
    ($ROWS,$COLS) = term_size();

    # Calculate dynamic layout requirements
    $legend_lines_needed = calculate_legend_lines_needed();
    $actual_footer_lines = calculate_footer_lines_needed();
    $actual_header_lines = $input_active ? 2 : 2;  # Extra line when input is active (Not right now)

    # Reserve space for header, footer, and legend
    my $avail = $ROWS - $actual_header_lines - $actual_footer_lines - $legend_lines_needed;
    if ($avail < $min_plot_height) {
        # Reduce legend space if needed
        my $min_legend = 1;
        $legend_lines_needed = $min_legend if $legend_lines_needed > $min_legend;
        $avail = $ROWS - $actual_header_lines - $actual_footer_lines - $legend_lines_needed;

        # Reduce header if still not enough space
        if ($avail < $min_plot_height && !$input_active) {
            $actual_header_lines = 1;
            $avail = $ROWS - $actual_header_lines - $actual_footer_lines - $legend_lines_needed;
        }

        die "Not enough vertical space (rows=$ROWS)\n" if $avail < $min_plot_height;
    }

    $plot_top = $actual_header_lines + 1;
    $legend_start_row = $ROWS - $actual_footer_lines - $legend_lines_needed + 1;

    if ($raw_output_active) {
        # Split available space between plot and raw output
        if ($raw_output_height == 0) {
            # First time opening - use half the available space
            $raw_output_height = int($avail / 2);
            $raw_output_height = 3 if $raw_output_height < 3;  # minimum height
        }

        # Ensure raw output doesn't exceed available space
        my $max_raw_height = $avail - 3;  # leave at least 3 lines for plot
        $raw_output_height = $max_raw_height if $raw_output_height > $max_raw_height;
        $raw_output_height = 3 if $raw_output_height < 3;

        $raw_output_top = $plot_top;
        $raw_output_bottom = $raw_output_top + $raw_output_height - 1;
        $cur_plot_top = $raw_output_bottom + 1;
    } else {
        $cur_plot_top = $plot_top;
    }

    $plot_bottom = $legend_start_row - 1;
    $plot_height = $plot_bottom - $plot_top + 1;
    $plot_left = $yaxis_w + $pad_left + 1;      # 1-based columns
    $plot_right = $COLS - $pad_right;
    $plot_right = $plot_left if $plot_right < $plot_left;
    $plot_width = $plot_right - $plot_left + 1;
}

# Map value -> column within [plot_left, plot_right]
sub val_to_col {
    my ($v, $vmin, $vmax) = @_;
    return $plot_left if $plot_width <= 1;
    my $t = ($v - $vmin) / (($vmax-$vmin) || 1e-9);
    $t = 0 if $t < 0; $t = 1 if $t > 1;
    my $x = int($t * ($plot_width-1));
    return $plot_left + $x;
}

# ---------------- Draw fixed bars ----------------
sub draw_header {
    my $barbg = $a_header_bg;

    # Row 1: Title and info
    print gotorc(1,1), $barbg, fg256(231), bold();
    my $mode = $opt{demo_mode} ? "DEMO" : "SERIAL";
    my $port_info = $opt{demo_mode} ? "" : " ($opt{serial_port}\@$opt{baud_rate})";
    my $fieldspec_info = $fieldspec_path ? " [" . (split('/', $fieldspec_path))[-1] . "]" : "";
    my $label = " Serial Data Plotter [$mode]$port_info$fieldspec_info ";
    $label = substr($label, 0, $COLS-1) if length($label) > $COLS-1;
    print $label, " " x ($COLS - 1 - length($label)), a_rst(), clr_eol();

    # Row 2: Input line (when active) or empty
    print gotorc(2,1), $barbg, fg256(231);
    if ($input_active) {
        my $prompt = " Send> ";
        my $available_width = $COLS - 1 - length($prompt);
        my $display_buffer = $input_buffer;
        my $display_cursor = $input_cursor;

        # Handle scrolling if input is too long
        if (length($display_buffer) > $available_width) {
            my $start_pos = $input_cursor - int($available_width * 0.8);
            $start_pos = 0 if $start_pos < 0;
            $display_buffer = substr($input_buffer, $start_pos, $available_width);
            $display_cursor = $input_cursor - $start_pos;
        }

        my $line = $prompt . $a_input . $display_buffer . $input_underscore;
        # Pad to full width
        # $line .= " " x ($COLS - 1 - length($line)) if length($line) < $COLS - 1;
        print $line . clr_eol();

        # Position cursor
        my $cursor_col = length($prompt) + $display_cursor + 1;
        print gotorc(2, $cursor_col);
        return;  # Don't clear EOL to preserve cursor position
    } else {
        # Empty line when input not active
        print clr_eol();
        # print " " x ($COLS - 1), a_rst(), clr_eol();
    }

    # Row 3: Empty (only when input is active)
    # Not using 3 lines for header. This was for when the input line was in the footer
    # if ($input_active) {
    #     print gotorc(3,1), $barbg, fg256(231);
    #     print " " x ($COLS - 1), a_rst(), clr_eol();
    # }
}

sub highlight_field_name {
    my ($field_name, $shortcut, $is_enabled) = @_;

    my $base_color = $is_enabled ? a_fieldname() : a_fieldname_disabled();
    return $base_color . $field_name  unless defined $shortcut;

    # Highlight the shortcut character in the field name
    my $highlighted_name = $field_name;
    if ($highlighted_name =~ s/(\Q$shortcut\E)/a_hotkey() . $shortcut . ${base_color}/e) {
        return $base_color . $highlighted_name;
    } else {
        # If shortcut not found in name, just append it
        return $base_color . $field_name . "(" . a_hotkey() . $shortcut .
            a_rst() . $base_color .  ")";
    }
}

# Calculate footer lines needed
sub calculate_footer_lines_needed {
    my $lines = 1;  # Always need at least one line for controls

    # Add line for debug message if present
    $lines++ if $debug_msg;

    return $lines;
}

# Calculate how many lines we need for group legend
sub calculate_group_lines_needed {
    return 0 unless %fieldspec && $fieldspec{groups};

    # Get groups that have shortcuts assigned
    my @display_groups = grep { $group_shortcuts{$_} } keys %{$fieldspec{groups}};
    return 0 if @display_groups == 0;

    # Calculate group display lengths more accurately
    my $total_length = 0;  # Start at 0, prefix already accounted for below
    my $available_width = $COLS - 2 - 8;  # Account for padding AND prefix
    my $lines = 1;

    for my $group_name (@display_groups) {
        my $shortcut = $group_shortcuts{$group_name} // '';

        # Calculate display text length more accurately (matching draw_legend logic)
        my $status_indicator = 1;  # "*" or " "
        my $shortcut_chars = $shortcut ? length($shortcut) + 2 : 0;  # "(x)" format
        my $padding = 3;  # spaces around text
        my $display_length = length($group_name) + $status_indicator + $shortcut_chars + $padding;

        if ($total_length + $display_length > $available_width) {
            $lines++;
            $total_length = $display_length;  # Reset for new line
        } else {
            $total_length += $display_length;
        }
    }

    return $lines;
}

# Calculate how many lines we need for legend
sub calculate_legend_lines_needed {
    my $group_lines = calculate_group_lines_needed();
    my $field_lines = 0;

    if ($S == 0) {
        return $group_lines;  # Only groups, no fields yet
    }

    # Get non-hidden fields for display
    my @display_fields;
    for my $i (0..$S-1) {
        my $field_name = $field_names[$i] // ($i + 1);
        next if is_field_hidden($field_name);  # Skip hidden fields
        push @display_fields, $i;
    }

    if (@display_fields == 0) {
        $field_lines = 1;  # At least one line for "no fields to show"
    } else {
        # Calculate field display lengths accurately
        my $total_length = 0;  # Start at 0, prefix already accounted for below
        my $available_width = $COLS - 2 - 8;  # Account for padding AND prefix
        $field_lines = 1;

        for my $i (@display_fields) {
            my $field_name = $field_names[$i] // ($i + 1);
            my $config = get_field_config($field_name);
            my $shortcut = $field_shortcuts{$field_name} // '';

            # Calculate display text length more accurately (matching draw_legend logic)
            my $glyph_length = 1;  # One character for glyph
            my $colon_space = 2;   # ": " after field name
            my $value_length = 8;  # Approximate value display length (-.--- to 1234.567)
            my $shortcut_chars = $shortcut ? length($shortcut) + 2 : 0;  # "(x)" format
            my $padding = 3;       # Spaces around the whole thing

            my $display_length = $glyph_length + length($field_name) + $colon_space +
                               $value_length + $shortcut_chars + $padding;

            if ($total_length + $display_length > $available_width) {
                $field_lines++;
                $total_length = $display_length;  # Reset for new line
            } else {
                $total_length += $display_length;
            }
        }
    }

    return $group_lines + $field_lines;
}

sub draw_legend {
    return if $legend_lines_needed <= 0;

    my $barbg = $a_legend_bg;
    my $current_row = $legend_start_row;

    # Draw groups first
    my $group_lines = calculate_group_lines_needed();
    if ($group_lines > 0) {
        my @display_groups = sort {
            ($fieldspec{groups}->{$a}->{order} // 999) <=>
            ($fieldspec{groups}->{$b}->{order} // 999)
        } grep { $group_shortcuts{$_} } keys %{$fieldspec{groups}};

        # Pre-calculate group display strings
        my @group_displays;
        for my $group_name (@display_groups) {
            my $is_enabled = $group_states{$group_name};
            my $shortcut = $group_shortcuts{$group_name} // '';

            # Create highlighted group name
            my $highlighted_name = highlight_field_name($group_name, $shortcut, $is_enabled);

            # Add status indicator
            my $status_indicator = $is_enabled ? "*" : " ";

            # Build display text
            my $display_text = sprintf("%s%s  ", $highlighted_name, $status_indicator);

            # Approximate length for layout
            my $approx_length = length($group_name) + length($status_indicator) +
                               ($shortcut ? length($shortcut) + 2 : 0) + 3;

            push @group_displays, {
                text => $display_text,
                length => $approx_length,
                group_name => $group_name,
                is_enabled => $is_enabled,
            };
        }

        # Distribute groups across available lines
        my $current_group = 0;

        for my $line_idx (0..$group_lines-1) {
            my $r = $current_row + $line_idx;
            print gotorc($r, 1), $barbg, fg256(231);

            my $line_content = " ";
            my $available_width = $COLS - 2;  # Account for padding

            if ($line_idx == 0) {
                $line_content .= "Groups: ";
                $available_width -= 8;  # "Groups: " = 8 chars
            } else {
                $line_content .= "        ";  # Indent continuation lines
                $available_width -= 8;
            }

            my $current_line_length = 0;  # Prefix len already removed

            # Add as many groups as will fit on this line
            while ($current_group < @group_displays &&
                   $current_line_length + $group_displays[$current_group]->{length} <= $available_width) {

                my $group = $group_displays[$current_group];

                # Add the group with proper color coding
                my $color = $group->{is_enabled} ? fg256(231) : fg256(240);
                $line_content .= $barbg . $color . $group->{text};

                $current_line_length += $group->{length};
                $current_group++;
            }

            # Pad the line to full width
            my $clean_content = $line_content;
            $clean_content =~ s/\e\[[0-9;]*m//g;
            my $padding_needed = $COLS - 1 - length($clean_content);
            $padding_needed = 0 if $padding_needed < 0;
            $line_content .= " " x $padding_needed;

            print $line_content, a_rst(), clr_eol();

            # If we've shown all groups, clear remaining group lines
            if ($current_group >= @group_displays) {
                for my $remaining_line ($line_idx + 1..$group_lines-1) {
                    my $clear_r = $current_row + $remaining_line;
                    print gotorc($clear_r, 1), $barbg, fg256(231);
                    print " " x ($COLS - 1), a_rst(), clr_eol();
                }
                last;
            }
        }

        $current_row += $group_lines;
    }

    # Draw fields
    return if $S == 0;  # No fields to draw

    # Get non-hidden fields for display (both enabled and disabled)
    my @display_fields;
    for my $i (0..$S-1) {
        my $field_name = $field_names[$i] // ($i + 1);
        next if is_field_hidden($field_name);  # Skip hidden fields only
        push @display_fields, $i;
    }

    # Handle case where no fields are available for display
    if (@display_fields == 0) {
        my $r = $current_row;
        print gotorc($r, 1), $barbg, fg256(231);
        my $msg = " No fields to display ";
        my $line = $msg . " " x ($COLS - 1 - length($msg));
        print $line, a_rst(), clr_eol();

        # Clear remaining legend lines
        my $remaining_lines = $legend_lines_needed - $group_lines - 1;
        for my $remaining_line (1..$remaining_lines) {
            my $clear_r = $current_row + $remaining_line;
            print gotorc($clear_r, 1), $barbg, fg256(231);
            print " " x ($COLS - 1), a_rst(), clr_eol();
        }
        return;
    }

    # Pre-calculate field display strings
    my @field_displays;
    for my $i (@display_fields) {
        my $field_name = $field_names[$i] // ($i + 1);
        my $config = get_field_config($field_name);
        my $is_enabled = is_field_enabled($field_name);
        my $g = $config->{ch} // $glyphs[$i % @glyphs];
        my $shortcut = $field_shortcuts{$field_name} // '';

        my $value_str;
        if (defined $values[$i]) {
            # Format numbers based on magnitude for better display
            my $val = $values[$i];
            if (abs($val) >= 1000) {
                $value_str = sprintf("%.0f", $val);
            } elsif (abs($val) >= 100) {
                $value_str = sprintf("%.1f", $val);
            } elsif (abs($val) >= 10) {
                $value_str = sprintf("%.2f", $val);
            } else {
                $value_str = sprintf("%.3f", $val);
            }
        } else {
            $value_str = "-.---";
        }

        # Create highlighted field name
        my $highlighted_name = highlight_field_name($field_name, $shortcut, $is_enabled);

        # Add OFF indicator for disabled fields
        # my $status_indicator = $is_enabled ? "" : " [OFF]"; # Takes up too much space
        my $status_indicator = '';

        # Build display text with glyph and value
        my $display_text = sprintf("%s %s:%s%s  ", $g, $highlighted_name, $value_str, $status_indicator);

        # Approximate length for layout (ignoring color codes)
        my $approx_length = length($g) + 1 + length($field_name) + 1 + length($value_str) +
                           ($shortcut ? length($shortcut) + 2 : 0) + 3;
                           # ($is_enabled ? 0 : 6) + 3;  # 6 for " [OFF]" takes too much space

        # Determine color from field config or default
        my $color;
        my $is_rgb = 0;
        if ($config->{fg24}) {
            # RGB color specified
            $color = $config->{fg24};
            $is_rgb = 1;
        } elsif (defined $config->{fg}) {
            # 256-color specified
            $color = $config->{fg};
        } else {
            # Default color
            $color = $colors[$i % @colors];
        }

        # Dim color for disabled fields
        if (!$is_enabled && !$is_rgb) {
            # For 256-color, use a dimmed version
            $color = 240;  # Gray
        } elsif (!$is_enabled && $is_rgb) {
            # For RGB, dim by reducing all components
            $color = [map { int($_ * 0.5) } @$color];
        }

        push @field_displays, {
            text => $display_text,
            length => $approx_length,
            color => $color,
            index => $i,
            is_rgb => $is_rgb,
            is_enabled => $is_enabled,
        };
    }

    # Distribute fields across remaining available lines
    my $field_lines = $legend_lines_needed - $group_lines;
    my $current_field = 0;

    for my $line_idx (0..$field_lines-1) {
        my $r = $current_row + $line_idx;
        print gotorc($r, 1), $barbg, fg256(231);

        my $line_content = " ";
        my $available_width = $COLS - 2;  # Account for padding

        if ($line_idx == 0) {
            $line_content .= "Fields: ";
            $available_width -= 8;  # "Fields: " = 8 chars
        } else {
            $line_content .= "        ";  # Indent continuation lines
            $available_width -= 8;
        }

        my $current_line_length = 0;  # "Fields:" len already removed

        # Add as many fields as will fit on this line
        while ($current_field < @field_displays &&
               $current_line_length + $field_displays[$current_field]->{length} <= $available_width) {

            my $field = $field_displays[$current_field];

            # Add the field with proper color coding for the glyph
            my $color_code;
            if ($field->{is_rgb}) {
                $color_code = fg24(@{$field->{color}});
            } else {
                $color_code = fg256($field->{color});
            }

            # Get the actual display text and add glyph coloring
            my $display = $field->{text};
            if ($display =~ /^(\S+) (.+)$/) {
                my ($glyph, $rest) = ($1, $2);
                $line_content .= $barbg . $color_code . $glyph .
                               $barbg . fg256(231) . " " . $rest;
                # $line_content .= a_rst() . $color_code . $glyph .
                #                a_rst() . bg256($barbg) . fg256(231) . " " . $rest;
            } else {
                $line_content .= $barbg . fg256(231) . $display;
                # $line_content .= a_rst() . bg256($barbg) . fg256(231) . $display;
            }

            $current_line_length += $field->{length};
            $current_field++;
        }

        # Pad the line to full width
        my $padding_needed = $COLS - 1 - length($line_content);
        # Calculate padding more accurately by removing ANSI codes
        my $clean_content = $line_content;
        $clean_content =~ s/\e\[[0-9;]*m//g;
        $padding_needed = $COLS - 1 - length($clean_content);
        $padding_needed = 0 if $padding_needed < 0;
        $line_content .= " " x $padding_needed;

        print $line_content, a_rst(), clr_eol();

        # If we've shown all fields, clear remaining legend lines
        if ($current_field >= @field_displays) {
            for my $remaining_line ($line_idx + 1..$field_lines-1) {
                my $clear_r = $current_row + $remaining_line;
                print gotorc($clear_r, 1), $barbg, fg256(231);
                print " " x ($COLS - 1), a_rst(), clr_eol();
            }
            last;
        }
    }
}

sub draw_footer {
    return if $actual_footer_lines <= 0;
    my $barbg = $a_footer_bg;

    for my $i (0..$actual_footer_lines-1) {
        my $r = $ROWS - $actual_footer_lines + 1 + $i;
        print gotorc($r,1), $barbg, fg256(231), bold();
        my $label = "";

        if ($i == 0) {
            my $raw_status = $raw_output_active ? " ^D=close raw" : " ^D=raw panel";
            my $raw_resize = $raw_output_active ? " +/-=resize" : "";
            my $shortcuts_info = %fieldspec ? " [fld/grp keys active]" : "";
            $label = " q=quit N=toggle numbers ^T=Term.input$raw_status$raw_resize$shortcuts_info Flds:$S ^Y:Clrs ^W:Wr.Fields";
        } elsif ($i == 1 && $debug_msg) {
            $label = $debug_msg;
        }

        # Ensure label doesn't exceed terminal width
        $label = substr($label, 0, $COLS - 1) if length($label) > $COLS - 1;
        my $padding = $COLS - 1 - length($label);
        $padding = 0 if $padding < 0;
        my $line = $label . " " x $padding;
        print $line, $barbg, clr_eol(), a_rst();
    }
}

# ---------------- Render scaffolding ----------------
sub clear_screen { print esc("2J") }

sub set_debug($msg) {
    $debug_msg = sprintf(" DEBUG[%d] $msg ", time()%1000);
    draw_footer();
}

sub full_redraw {
    reset_scroll_region();
    clear_screen();
    set_debug("Redraw (plot:$cur_plot_top-$plot_bottom) (Line: $need_redraw_line, Reason: $need_redraw_msg)");

    draw_header();
    draw_legend();
    draw_footer();
    if ($raw_output_active) {
        clear_raw_output_area();
    }
    replay_history();
}

# ---------------- Input handling ----------------
sub set_raw_tty {
    system("stty -echo -icanon time 0 min 0 2>/dev/null"); # nonblocking read
}

sub restore_tty {
    system("stty sane 2>/dev/null");
}

# ---------------- Data update ----------------
sub step_series_demo {
    for my $i (0..$S-1) {
        my $step = (rand() - 0.5) * $vol[$i];
        $values[$i] += $step;
        push @{$hist[$i]}, $values[$i];
        shift @{$hist[$i]} while @{$hist[$i]} > $hsize;
    }
}

# Build one row string containing all series glyphs at mapped columns
sub build_plot_row {
    my ($vmin, $vmax) = @_;
    return "" if $S == 0;  # No data yet

    my $width = $plot_width;
    my @buf = (' ') x $COLS;

    # draw series points (only for enabled and non-hidden fields)
    for my $i (0..$S-1) {
        my $field_name = $field_names[$i] // ($i + 1);
        next if is_field_hidden($field_name);   # Skip hidden fields
        next unless is_field_enabled($field_name);  # Skip disabled fields

        my $col = val_to_col($values[$i], $vmin, $vmax);
        my $config = get_field_config($field_name);
        my $glyph = $config->{ch} // $glyphs[$i % @glyphs];

        # Determine color from field config or default
        my $color_code;
        if ($config->{fg24}) {
            $color_code = fg24(@{$config->{fg24}});
        } elsif (defined $config->{fg}) {
            $color_code = fg256($config->{fg});
        } else {
            $color_code = fg256($colors[$i % @colors]);
        }

        if ($col >= 1 && $col <= $COLS) {
            # place only inside plot area; other cols remain spaces
            if ($col >= $plot_left && $col <= $plot_right) {
                $buf[$col-1] = $color_code . $glyph . a_rst();
                if ($inline_nums_on) {
                    my $num = ($i+1);
                    my $num_s = "$num";
                    for (my $k=0; $k<length($num_s); $k++) {
                        my $cc = $col + $k;
                        last if $cc > $plot_right;  # stay within plot boundaries
                        $buf[$cc-1] = $color_code . substr($num_s,$k,1) . a_rst();
                    }
                }
            }
        }
    }

    # optional subtle left/right borders for the plot area
    my $border_col = 244;
    # Left border: one column before plot area
    if ($plot_left-1 >= 1) {
        $buf[$plot_left-2] = fg256($border_col) . '│' . a_rst();
    }
    # Right border: one column after plot area
    my $right_border_col = $plot_right + 1;
    if ($right_border_col <= $COLS) {
        $buf[$right_border_col-1] = fg256($border_col) . '│' . a_rst();
    }

    # Return the visible line covering the whole width
    return join('', @buf[0..$COLS-1]);
}

sub window_minmax {
    my ($lo,$hi) = (1e9, -1e9);
    for my $i (0..$S-1) {
        my $field_name = $field_names[$i] // ($i + 1);
        next if is_field_hidden($field_name);    # Skip hidden fields
        next unless is_field_enabled($field_name);  # Skip disabled fields

        for my $v (@{$hist[$i]}) {
            $lo = $v if $v < $lo;
            $hi = $v if $v > $hi;
        }
    }
    # Ensure non-degenerate range
    if ($hi - $lo < 1e-6) { $hi += 1; $lo -= 1 }
    return ($lo,$hi);
}

# ---------------- Main ----------------
$| = 1;
hide_cursor();

sub cleanup {
    return if $cleaned;
    save_state();  # Save state on exit
    print a_rst();
    reset_scroll_region();
    show_cursor();
    print gotorc($ROWS,1), "\n";
    # close($data_fh) if $data_fh;
    if ($opt{stdin_mode} || $opt{cmd}) {
        system("stty -F /dev/tty sane 2>/dev/null");
    }
    $cleaned = 1;
}

# WINCH handler: recompute layout and redraw
$SIG{WINCH} = sub {
    recompute_layout();
    $need_redraw = 1;
};

# Die/quit handlers
$SIG{INT}  = sub { cleanup(); restore_tty(); exit 130 };
$SIG{TERM} = sub { cleanup(); restore_tty(); exit 143 };
$SIG{__DIE__} = sub { cleanup(); restore_tty(); die @_ };

# Load state and fieldspec
load_state();
if ($opt{fieldspec}) {
    load_fieldspec($opt{fieldspec}) or die "Failed to load fieldspec: $opt{fieldspec}\n";
}

# Initialize data source
init_data();
unless ($opt{demo_mode}) {
    eval { open_data_source(); };
    if ($@) {
        if ($@ && $data_source_type ne 'demo') {
            die "open_data_source() failed: $@";
        }
        init_data();
    }
}

# Initial layout & draw
recompute_layout();
full_redraw();
set_raw_tty(); # Nonblocking input

if ($opt{stdin_mode}) {
    # When reading data from stdin, get keyboard from /dev/tty
    open($kb_input_fh, "<", "/dev/tty") || die "Can't open /dev/tty: $!";
    system("stty -F /dev/tty -echo -icanon time 0 min 0 2>/dev/null");
} else {
    # Otherwise use stdin for keyboard
    $kb_input_fh = *STDIN;
}

while (1) {
    my $key = ''; # Either a character or a sequence
    my $combokey_delay_ms = 70;
    my $combokey_start_ms = 0;
    my $combokey_sequence = '';

    my $n = sysread($kb_input_fh, $key, 1);

    if (!defined $n || $n < 0) { # No chars available
        if ($combokey_start_ms) { # We had a combo key (ie. ESC) before
            if (millis() - $combokey_start_ms > $combokey_delay_ms) {
                # Timeout the sequence
                $key = $combokey_sequence; # pass through the key alone
                $combokey_sequence = '';
                $combokey_start_ms = 0;
            }
        }
    } else { # Char is available
        my $keytime = millis();
           # We had an ESC before (len $combokey_sequence will also be >0)
        if ($combokey_start_ms) {
            if (millis() - $combokey_start_ms > $combokey_delay_ms) { # but it timed out.
                $combokey_start_ms = 0;
                $key = $combokey_sequence; # Pass it through, even if it's short
            } else { # didn't time out, so add to sequence and refresh the timer
                $combokey_sequence .= $key;
                $combokey_start_ms = $keytime;
            }
        } else { # char is available but we're not in a sequence
            if ($key eq "\033") {
                $combokey_sequence = "\033";
                $combokey_start_ms = $keytime; # Now we're in a sequence
            } else {
                $combokey_start_ms = 0;  # make sure we're not in a sequence going forward
                $combokey_sequence = ''; # Probably unnecessary to wipe
            }
        }
    }
    if (defined $key && length $key) {
        my $ord_ch = -1;
        $ord_ch = ord($key) if length $key == 1; # Only get ascii value if is single char
        if ($input_active) { # Handle serial Send input mode
            # ^T and a blank enter will end input mode (unless that's disabled)
            if ($ord_ch == 20) {  # ^t (CTRL+t)
                $input_active = 0;
                draw_header();
            } elsif ($ord_ch == 20) {  # ^T (CTRL+t) # Terminal/serial line input
                # Check if input mode is supported
                if ($data_source_type ne 'serial') {
                    set_debug("Terminal input (^T) only available in serial mode");
                } else {
                    $input_active = 0;
                    draw_header();
                }
            } elsif (length($input_buffer)<1 && !$opt{no_enter_ends_input} &&
                    ($key eq "\n" || $key eq "\r")) {
                $input_active = 0;
                draw_header();
            } elsif ($key eq "\n" || $key eq "\r") {  # Enter with something in buffer
                # Send the input (WITH the trailing enter)
                if (length($input_buffer) > 0) {
                    send_serial_data("$input_buffer$key");
                    $input_buffer = "";
                    $input_cursor = 0;
                    draw_header();  # Update display but stay in input mode
                }
                # Stay in input mode - don't set $input_active = 0
            } elsif ($ord_ch == 127 || $ord_ch == 8) {  # Backspace/Delete
                if ($input_cursor > 0) {
                    substr($input_buffer, $input_cursor - 1, 1) = '';
                    $input_cursor--;
                    draw_header();  # Immediate update
                }
            } elsif ($ord_ch == 27) {  # Escape - cancel input
                $input_buffer = "";
                $input_cursor = 0;
                $input_active = 0;
                draw_header();  # Immediate update
                $need_redraw = 1;
            } elsif ($ord_ch >= 32 && $ord_ch <= 126) {  # Printable characters
                substr($input_buffer, $input_cursor, 0) = $key;
                $input_cursor++;
                draw_header();  # Immediate update
            }
            # Arrow keys and other special handling could go here
        } else {
            # Handle normal mode
            if ($key eq 'q') {
                last;
            } elsif ($key eq 'N') {
                $inline_nums_on = !$inline_nums_on;
            } elsif ($ord_ch == 23) {  # ^W (CTRL+W) # Write fieldspec template
                write_fieldspec_template();
            } elsif ($ord_ch == 25) {  # ^Y (CTRL+y)
                @colors = shuffle @colors;
            } elsif ($ord_ch == 20) {  # ^T (CTRL+t)
                # Check if input mode is supported
                if ($data_source_type ne 'serial') {
                    set_debug("Terminal input (^T) only available in serial mode");
                } else {
                    $input_active = 1;
                    $input_buffer = "";
                    $input_cursor = 0;
                    recompute_layout();  # Recalculate layout with input
                    draw_header();
                }
                # $need_redraw = 1;
            } elsif ($ord_ch == 4) {  # ^D (Ctrl+D)
                $raw_output_active = !$raw_output_active;
                if ($raw_output_active) {
                    # Just opened - clear any buffered plot data
                    @plot_data_buffer = ();
                    $cur_plot_top = $raw_output_bottom+1;
                } else {
                    # Just closed - process any buffered plot data
                    for my $buffered_data (@plot_data_buffer) {
                        my ($names, $values) = @$buffered_data;
                        update_fields($names, $values);
                    }
                    @plot_data_buffer = ();
                    $cur_plot_top = $plot_top;
                }
                recompute_layout();
                $need_redraw = 1;
            } elsif ($key eq '+' && $raw_output_active) {
                # Increase raw output height
                $raw_output_height += 2;
                recompute_layout();
                $need_redraw = 1;
            } elsif ($key eq '-' && $raw_output_active) {
                # Decrease raw output height
                $raw_output_height -= 2;
                $raw_output_height = 3 if $raw_output_height < 3;  # minimum
                recompute_layout();
                $need_redraw = 1;
            } elsif ($shortcut_to_group{$key}) {
                # Group toggle
                toggle_group($shortcut_to_group{$key});
                # recompute_layout();  # Recalculate in case legend size changed
                # $need_redraw = 1;
            } elsif ($shortcut_to_field{$key}) {
                # Field toggle
                toggle_field($shortcut_to_field{$key});
                # recompute_layout();  # Recalculate in case legend size changed
                # $need_redraw = 1;
            } else {
                set_debug("Unknown key hit ord:$ord_ch");
            }
        }
    }

    if ($need_redraw) {
        full_redraw();
        $need_redraw = 0;
    }

    # Read and process data
    my $data_updated = 0;
    if ($data_source_type eq 'demo') {
        step_series_demo();
        $data_updated = 1;
    } else {
        my @lines = read_data_source();
        for my $line (@lines) {
            next if $line =~ /^\s*$/;  # Skip empty lines

            # Try to parse as plot data first
            my ($names, $values) = parse_arduino_line($line);
            if (@$names > 0) {
                # This is valid plot data
                push @plot_data_buffer, [$names, $values];
                # Process plot data normally
                $data_updated = update_fields($names, $values);
            } else {
                # This is not plot data - route to raw output if active
                if ($raw_output_active) {
                    output_raw_line($line);
                }
                # If raw output is not active, just ignore non-plot lines
            }
        }
    }

    # Only plot if we have data, it was updated, and at least one field is enabled
    if ($data_updated && $S > 0) {
        # Check if any fields are enabled
        my $any_enabled = 0;
        for my $i (0..$S-1) {
            my $field_name = $field_names[$i] // ($i + 1);
            if (is_field_enabled($field_name)) {
                $any_enabled = 1;
                last;
            }
        }

        if ($any_enabled) {
            my ($vmin,$vmax) = window_minmax();
            # Build one row and print it at bottom of scroll region
            my $row = build_plot_row($vmin,$vmax);
            setup_plot_output_scroll();
            print gotorc($plot_bottom, 1), $row, clr_eol(), "\n";
        }

        # Update legend periodically to avoid interference with scrolling
        $legend_update_counter++;
        my $update_legend = $need_redraw || ($legend_update_counter % 10 == 0);  # Every 10th update
        if ($update_legend) {
            draw_legend();
        }
    }

    Time::HiRes::sleep($sleep_s) if $sleep_s > 0;
}

restore_tty();
cleanup();
exit 0;

# vim: et ts=4 sts=4 sw=4
